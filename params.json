{"name":"Service Cutter","tagline":"A Structured Way to Service Decomposition","body":"The Service Cutter suggests a structured way to service decomposition. This tutorial helps you to work with the Service Cutter. You should have access to a test installation or install the Service Cutter on your machine in order to try the samples.\r\n\r\nYou will learn how to import data into the Service Cutter and analyze service cuts. The last section outlines two possible usage scenarios.\r\n\r\n\r\n# Core Concepts\r\n\r\n- **Nanoentities** ([see definition](https://github.com/ServiceCutter/ServiceCutter/wiki/Concepts#nanoentity)) are the building blocks of services.\r\n- A **User Representation** is a concept familiar to the architect that can be used to feed the criteria information into the Service Cutter.\r\n- A **Coupling Criterion** describes an architecturally significant requirement why two nanoentities should or should not be owned by the same service. These criteria define the semantic model on which the Service Cutter is built on.\r\n\r\n# Data Import\r\nThe importer tab allows you to import nanoentities and user representations.\r\n\r\n![Screenshot Menu Import](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-menu-import.png)\r\n\r\nCurrently updates are not possible. You have to import a new model after applying changes to the files.\r\n\r\n## Domain Model\r\n\r\nTo begin with, a domain model in the form of an [ERM](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model) needs to be imported.\r\n\r\n![Screenshot Upload Model](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-import-model.png)\r\n\r\nA simple domain model can be found in the samples folder. Let's try with `ServiceCutter/Samples/ddd_1_model.json` for now.\r\n\r\n## User Representations\r\n\r\nTo suggest good service cuts, we need more data. The file `ServiceCutter/Samples/ddd_2_user_representations.json` enhances the domain model with Use Cases, characteristics of the nanoentities and responsible roles.\r\n\r\n![Screenshot upload user representations](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-import-userrepresentations.png)\r\n\r\nNow we have all the data we need. Let's continue with the analysis.\r\n\r\n# Service Cut Analysis\r\n\r\n![Screenshot Menu Solver](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-menu-solver.png)\r\n\r\nThe solver tab allows you to see candidate service cuts, choose an underlying algorithm, and define criteria prioritities.\r\n\r\n![Screenshot Candidate Service Cut](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-cargo-leung.png)\r\n\r\n## Algorithms\r\n\r\nThe Service Cutter maps all imported data onto a graph. The nanoentities are the nodes and the coupling between nanoentities is stored on weighted, undirected edges.\r\n\r\nThe Service Cutter uses graph clustering algorithms to find densely connected clusters which are presented as candidate services. Currently two different algorithms are supported:\r\nThe \"Epidemic Label Propagation\" by [**Leung** et al](http://arxiv.org/pdf/0808.2633.pdf) is non-deterministic and finds an optimal number of clusters. Use the recalculate button to see different service cuts.\r\n\r\n![Screenshot Leung](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-algo-leung.png)\r\n\r\nThe **Girvan-Newman** algorithm by [M. Girvan and M. E. J. Newman](http://arxiv.org/abs/cond-mat/0112110) is deterministic and finds a given number of clusters. \r\n\r\n_Hint: You cannot see different service cuts with Girvan-Newman as this algorithm is deterministic. You have to adjust the parameters to see different service cuts._\r\n\r\n![Screenshot Girvan-Newman](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-algo-gn.png)\r\n\r\n## Parameters\r\n\r\nThe parameters can be used to influence the candidate service cuts. Modify the coupling criteria in such a way that they reflect the your system's context. Consistency for example is significantly divergent in a banking environment compared to an online social network.\r\n\r\n![Screenshot priorities](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-priorities.png)\r\n\r\n## Analysis mode\r\n\r\nActivate the analysis mode to understand the implications of a candidate service cut. \r\n\r\n![Screenshot Button](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-analysis-button.png)\r\n\r\nThe analysis mode activates the following features:\r\n* An connection between the services is drawn when a use case exists that uses nanoentities of both services.\r\n\r\n![Screenshot Service Connection](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-analysis-example.png)\r\n\r\n* You can click on a service or a connection between two services and the Service Cutter will display the Published Language of the selected service.\r\n\r\n![Screenshot Published Language](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-analysis-service.png)\r\n\r\n_Hint: The analysis mode is only available with use cases present._\r\n\r\n# Scenarios\r\n\r\nWe would like to highlight two possible usage scenarios of the Service Cutter.\r\n\r\n## Green field\r\nThe pleasant scenario is the “green field”. You have not written a single line of code but already gathered an extensive set of Use Cases, an ERM and other characterizations. You load all this data into the Service Cutter and use the suggested service cuts for an inspiring discussion with your team’s architects. Finally, you agree on a set of services and proceed to building them.\r\n* [\"Microservices\"](http://martinfowler.com/articles/microservices.html) by Martin Fowler  \r\n\r\n## Monolith to microservice\r\nThe likely scenario with existing software is the transition from a monolith to a microservice architecture. You’ve been working on an application for quite a while and you and your team only implemented a single service. After carefully reviewing your architecture, you decided that the time has come to split your application into services. This leaves to you with one big question: \"Where shall I start?\" The Service Cutter is able to identify candidate service cuts with a given number of services. You can use the Girvan-Newman algorithm and set the number of clusters to two. Then iteratively increase the number of services by one and you will see a possible path towards an architecture based on services.\r\n\r\n* [\"MonolithFirst\"](http://martinfowler.com/bliki/MonolithFirst.html) by Martin Fowler  \r\n\r\n# Service Cutter Benefits\r\n* By requesting different user representations, an architect is challenged to analyze which user representations and characteristics are relevant in his system. He might use the user representations as a check list for requirements engineering.\r\n* The user representations and coupling criteria can be used to educate junior architects or students on the driving forces of service decomposition.\r\n* The Service Cutter provides candidate service cuts based on the defined user representations. With these candidate service cuts the architects expectations of the number of services and their definition is either verified or challenged. \r\n* Use cases are assigned to their responsible service. The published language between services is displayed in order to assist the development of services and their interfaces to each other.\r\n* By storing the candidate service cuts, architectural decisions can be persisted and documented (not yet implemented).\r\n\r\n\r\n# Further Resources\r\n\r\n* [Wiki](https://github.com/ServiceCutter/ServiceCutter/wiki) with more details\r\n* [Service Cutter source code](https://github.com/ServiceCutter/ServiceCutter)\r\n* Bachelor Thesis by [Lukas Kölbener](https://github.com/koelbener) and [Michael Gysel](https://github.com/gysel) (not yet published)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}