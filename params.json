{"name":"Service Cutter","tagline":"A Structured Way to Service Decomposition","body":"# Service Cutter\r\n\r\nThe Service Cutter suggests a structured way to service decomposition. This tutorial helps you to work with the Service Cutter.\r\n\r\nYou will learn how to import data into the Service Cutter and analyze service cuts. The last section outlines two possible usage scenarios.\r\n\r\n## Core Concepts\r\n\r\nTODOD\r\n\r\n- Nanoentity\r\n- User Representation\r\n- Coupling Criterion\r\n\r\n## Data Import\r\nThe importer tab allows you to import nanoentities and user representations.\r\n\r\n![Screenshot Menu Import](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-menu-import.png)\r\n\r\nCurrently updates are not possible. You have to import a new model after applying changes to the files.\r\n\r\n### Domain Model\r\n\r\nTo begin with, a domain model in the form of an [ERM](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model) needs to be imported.\r\n\r\n![Screenshot Upload Model](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-import-model.png)\r\n\r\nA simple domain model can be found in the samples folder. Let's try with `ServiceCutter/Samples/ddd_1_model.json` for now.\r\n\r\n### User Representations\r\n\r\nTo suggest good service cuts, we need more data. The file `ServiceCutter/Samples/ddd_2_user_representations.json` enhances the domain model with Use Cases, characteristics of the nanoentities and responsible roles.\r\n\r\n![Screenshot upload user representations](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-import-userrepresentations.png)\r\n\r\nNow we have all the data we need. Let's continue with the analysis.\r\n\r\n## Service Cut Analysis\r\n\r\n![Screenshot Menu Solver](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-menu-solver.png)\r\n\r\nThe solver tab allows you to see candidate service cuts and modifiy the underlying algorithms, it's parameters and the prioritities.\r\n\r\n![Screenshot Candidate Service Cut](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-cargo-leung.png)\r\n\r\nThe Service Cutter maps all imported data onto a graph. The nanoentities are the nodes and the coupling between nanoentities is stored on weighted, undirected edges.\r\n\r\n### Algorithms\r\n\r\nThe Service Cutter uses graph clustering algorithms to find densely connected clusters which are presented as candidate service cut. Currently two different algorithms are supported:\r\nThe \"Epidemic Label Propagation\" by [**Leung** et al](http://arxiv.org/pdf/0808.2633.pdf) is non-deterministic and finds an optimal number of clusters. Use the recalculate button to see different service cuts.\r\n\r\n![Screenshot Leung](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-algo-leung.png)\r\n\r\nThe **Girvan-Newman** algorithm by [M. Girvan and M. E. J. Newman](http://arxiv.org/abs/cond-mat/0112110) is deterministic and finds a given number of clusters. \r\n\r\n_Hint: You cannot see different service cuts with Girvan-Newman as this algorithm is deterministic. You have to adjust the parameters to see different service cuts._\r\n\r\n![Screenshot Girvan-Newman](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-algo-gn.png)\r\n\r\nWe recommend to start with Leung and then analyze specific numbers of services with Girvan-Newman.\r\n\r\n### Parameters\r\n\r\nThe parameters can be used to influence the candidate service cuts. Modify the coupling criteria in such a way that they reflect the your system's context. Security and consistency for example are significantly divergent in a banking environment compared to an online social network.\r\n\r\n![Screenshot priorities](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-priorities.png)\r\n\r\n### Analysis mode\r\n\r\nActivate the analysis mode to understand the implications of a candidate service cut. \r\n\r\n![Screenshot Button](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-analysis-button.png)\r\n\r\nThe analysis mode activates the following features:\r\n* An connection between the services is drawn when a use case exists that uses nanoentities of both services.\r\n\r\n![Screenshot Service Connection](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-analysis-example.png)\r\n\r\n* You can click on a service or a connection between two services and the Service Cutter will display the Published Language of the selected service.\r\n\r\n![Screenshot Published Language](https://raw.githubusercontent.com/ServiceCutter/servicecutter.github.io/master/screenshot-solver-analysis-service.png)\r\n\r\n_Hint: The analysis mode is only available with use cases present._\r\n\r\n## Scenarios\r\n\r\nWe would like to highlight two possible usage scenarios of the Service Cutter.\r\n\r\n### Green field\r\nThe pleasant scenario is the “green field”. You have not written a single line of code but already gathered an extensive set of Use Cases, an ERM and other characterizations. You load all this data into the Service Cutter and use the suggested service cuts for an inspiring discussion with your team’s architects. Finally, you agree on a set of services and proceed to building them.\r\n* [\"Microservices\"](http://martinfowler.com/articles/microservices.html) by Martin Fowler  \r\n\r\n### Monolith to microservice\r\nThe likely scenario with existing software is the transition from a \"big ball of mud\" to a nice microservice architecture. You’ve been working on an application for quite a while and you and your team only implemented a single service: The monolith. After carefully reviewing your architecture you decided that the time has come to split your application into services. This leaves to you with one big question: \"Where shall I start?\" The Service Cutter is able to identify candidate service cuts with a given number of services. You can use the Girvan-Newman algorithm and set the number of clusters to two. Then iteratively increase the number of services by one and you will see a possible path towards an architecture based on services.\r\n\r\n* [\"MonolithFirst\"](http://martinfowler.com/bliki/MonolithFirst.html) by Martin Fowler  ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}